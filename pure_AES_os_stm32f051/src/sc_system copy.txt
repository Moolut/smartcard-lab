/*
 * sc_system.c
 *
 * Smartcard Demo OS
 *
 * T. Music 05/2023
 *
 */

#include <stddef.h>

#include <libopencm3/stm32/flash.h>
#include <libopencm3/stm32/gpio.h>
#include <libopencm3/stm32/rcc.h>
#include <libopencm3/stm32/usart.h>

#include "sc_system.h"

/*
    Function sys_gpio_init()

    Configures all GPIOs on the card and puts them into a predefined state

*/
void sys_gpio_init()
{
    // Enable the GPIO periphal clocks
    rcc_periph_clock_enable(RCC_GPIOA);
    rcc_periph_clock_enable(RCC_GPIOB);

    // Configure the LEDs
    // Set the GPIOs (LEDs are inverted)
    // Red and green led share a GPIO port
    gpio_set(PORT_LED_R, PIN_LED_R | PIN_LED_G);
    // Blue has its own GPIO port
    gpio_set(PORT_LED_B, PIN_LED_B);
    gpio_mode_setup(PORT_LED_R, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, PIN_LED_R | PIN_LED_G);
    gpio_set_output_options(PORT_LED_R, GPIO_OTYPE_OD, GPIO_OSPEED_2MHZ, PIN_LED_R | PIN_LED_G);
    gpio_mode_setup(PORT_LED_B, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, PIN_LED_B);
    gpio_set_output_options(PORT_LED_B, GPIO_OTYPE_OD, GPIO_OSPEED_2MHZ, PIN_LED_B);

    // 7816 Reset Disable Pin
    // By default this pin is strapped low on the pcb. Thus, if a card reader wants to
    // perform a reset, the STM32 will reset, too. In case you are debugging, you might not
    // want your card to be reset everytime the reader sees a timeout.
    gpio_clear(PORT_ISO7816_RST_DIS, PIN_ISO7816_RST_DIS);
    gpio_mode_setup(PORT_ISO7816_RST_DIS, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, PIN_ISO7816_RST_DIS);
    gpio_set_output_options(PORT_ISO7816_RST_DIS, GPIO_OTYPE_PP, GPIO_OSPEED_2MHZ, PIN_ISO7816_RST_DIS);

    // Clock Source Select Pin CLKSEL
    // When low, the STM32 receives the card reader clock on its HSE pin
    // This means, when selecting HSE as clock source, the controller runs with the wonky reader clock
    // this may be favorable for transmitting the ATR and further communication, but unfavorable for
    // performing measurements. Thus, this signal is high by default.
    gpio_set(PORT_CLKSEL, PIN_CLKSEL);
    gpio_mode_setup(PORT_CLKSEL, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, PIN_CLKSEL);
    gpio_set_output_options(PORT_CLKSEL, GPIO_OTYPE_PP, GPIO_OSPEED_2MHZ, PIN_CLKSEL);

    // Trigger Pin
    gpio_clear(PORT_TRIGGER, PIN_TRIGGER);
    gpio_mode_setup(PORT_TRIGGER, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, PIN_TRIGGER);
    gpio_set_output_options(PORT_TRIGGER, GPIO_OTYPE_PP, GPIO_OSPEED_100MHZ, PIN_TRIGGER);
}

void sys_set_reset_source(uint8_t src)
{
    if (src != SYSTEM_RSTSRC_ISO7816 && src != SYSTEM_RSTSRC_DBG_ONLY)
    {
        // Invalid source has been selected -> exit
        return;
    }

    if (src == SYSTEM_RSTSRC_ISO7816)
        gpio_clear(PORT_ISO7816_RST_DIS, PIN_ISO7816_RST_DIS);
    else
        gpio_set(PORT_ISO7816_RST_DIS, PIN_ISO7816_RST_DIS);

    return;
}

void sys_rcc_init()
{
    // Some general settings for the clock configuration

    // Also the card will never have clock speeds > 8 MHz, so keep the
    // flash wait states at zero
    flash_set_ws(FLASH_ACR_LATENCY_0WS);

    // At this time we are running from the HSI, so 8 MHz
    rcc_ahb_frequency = 8000000;
    rcc_apb1_frequency = 8000000;
    rcc_apb2_frequency = 8000000;
}

// Set the desired clock source for the system.
// Changing the system clock requires adjusting divider
// settings throughout the system for peripherals like USART
void sys_set_clksource(uint8_t src)
{
    if (src != SYSTEM_CLKSOURCE_CARD_TERMINAL && src != SYSTEM_CLKSOURCE_EXT_8MHZ)
    {
        // Invalid source has been selected -> exit
        return;
    }

    // As both clock options are being received through the HSE pin,
    // hop on the internal oscillator for the time between changing
    rcc_osc_on(RCC_HSI);
    rcc_wait_for_osc_ready(RCC_HSI);
    rcc_set_sysclk_source(RCC_HSI);

    rcc_osc_off(RCC_HSE);
    // Bypass the oscillator -> we are supplied by a stable clock
    RCC_CR |= RCC_CR_HSEBYP;

    // The desired clock source is the card terminal
    if (src == SYSTEM_CLKSOURCE_CARD_TERMINAL)
    {
        // Set CLKSEL pin low to disable the pcb oscillator
        // and pass through the card terminal clock
        gpio_clear(PORT_CLKSEL, PIN_CLKSEL);
    }
    else
    {
        gpio_set(PORT_CLKSEL, PIN_CLKSEL);
    }

    // Re-enable the HSE
    rcc_osc_on(RCC_HSE);
    rcc_wait_for_osc_ready(RCC_HSE);
    rcc_set_sysclk_source(RCC_HSE);

    // Turn off the HSI
    rcc_osc_off(RCC_HSI);

    return;
}

void sys_usart_init()
{
    // Enable the USART1 peripheral clock
    rcc_periph_clock_enable(RCC_USART1);

    // Configure GPIOs for USART1 TX
    gpio_mode_setup(PORT_USART1_TX, GPIO_MODE_AF, GPIO_PUPD_NONE, PIN_USART1_TX);
    gpio_set_output_options(PORT_USART1_TX, GPIO_OTYPE_PP, GPIO_OSPEED_2MHZ, PIN_USART1_TX);
    gpio_set_af(PORT_USART1_TX, GPIO_AF1, PIN_USART1_TX);

    // Configure USART1 baudrate
    // F = 372 , D = 1
    // Baudrate = 4750000 / (372 * 1) = 12768.817
    usart_set_baudrate(USART1, (4750000 / (372 * 1)));

    // USART1_GTPR = 16 >> 1; // Prescaler

    // Set the guard time to 8 etu
    USART1_GTPR = 2 << 8;

    // Baudrate = 4750000 / 372 = 12768.817
    // GTPR = 8 => 3B  , C8  , 11  , 00 P

    // Baudrate = 12900
    // GTPR = 8 => E7 P, 90  , 11  , 00
    //          => 3B  , 90  , C6 P, 00 P
    // GTPR = 7 => 3B  , C0 P, 11  , 00
    //          => E7 P, 90  , 01 P, 00 P
    // GTPR = 6 => 3B  , C8  , C6 P, 00 P
    //          => FE  , FA P, 84 P, 00

    // Configure USART1 Smartcard mode
    USART1_CR3 |= USART_CR3_SCEN;   // Enable Smartcard mode
    USART1_CR2 |= USART_CR2_CLKEN;  // Enable the clock output
    USART1_CR2 &= ~USART_CR2_LINEN; // Disable LIN mode
    USART1_CR1 |= USART_CR1_M |     // Enable 9-bit data mode (8-data bits + parity)
                  USART_CR1_PCE |   // Enable parity control
                  USART_CR1_TE |    // Enable transmitter
                  USART_CR1_UE;     // Enable USART

    // Set stop bits to 1.5 stop bits
    USART1_CR2 |= USART_CR2_STOPBITS_1_5;

    // Clear the Transmission Complete flag
    USART1_ICR |= USART_ICR_TCCF;

    // Enable Transmission Complete interrupt
    USART1_CR1 |= USART_CR1_TCIE;

    // delay_cyc(372);

    return;
}

void sys_usart_send(uint8_t *data, size_t len)
{
    for (size_t i = 0; i < len; i++)
    {
        // Wait until the transmit buffer is empty
        while (!(USART1_ISR & USART_ISR_TXE))
            ;

        // Send the data
        USART1_TDR = data[i];
    }

    // Wait for the last byte to complete transmission
    while (!(USART1_ISR & USART_ISR_TC))
        ;

    // Clear the TC flag
    USART1_ICR = USART_ICR_TCCF;
}

void sys_usart_send_atr(void)
{
    // ATR Sequence (Answer-to-Reset)
    static const uint8_t atr[] = {0x3B, 0x90, 0x11, 0x00}; // ATR bytes as per Python script

    // Send the ATR
    sys_usart_send(atr, sizeof(atr));

    // USART1_TDR = atr[0];
}

void delay_cyc(uint32_t cycles)
{
    // The loop translates to roughly two cycles,
    // so just div cycles by two and we good
    cycles = cycles >> 1;
    while (cycles > 0)
    {
        cycles--;
        __asm__("nop");
    }
}
