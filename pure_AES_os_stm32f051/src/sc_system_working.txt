/*
 * sc_system.c
 *
 * Smartcard Demo OS
 *
 * T. Music 05/2023
 *
 */

#include <stddef.h>
#include <stdbool.h>
#include <string.h>

#include <libopencm3/stm32/flash.h>
#include <libopencm3/stm32/gpio.h>
#include <libopencm3/stm32/rcc.h>
#include <libopencm3/stm32/usart.h>

#include "sc_system.h"
#include <src/AES/aes.h>

#define SIZE(a) sizeof(a) / sizeof(a[0])

/*
    Function sys_gpio_init()

    Configures all GPIOs on the card and puts them into a predefined state

*/

const uint8_t master_key[16] = {0xA2, 0xD0, 0xF1, 0x24, 0x4A, 0xAA, 0x94, 0xD0, 0xA7, 0x25, 0x4F, 0x26, 0xEB, 0x6D, 0x88, 0x05};
struct AES_ctx aes_ctx;

void sys_gpio_init()
{
    // Enable the GPIO periphal clocks
    rcc_periph_clock_enable(RCC_GPIOA);
    rcc_periph_clock_enable(RCC_GPIOB);

    // Configure the LEDs
    // Set the GPIOs (LEDs are inverted)
    // Red and green led share a GPIO port
    gpio_set(PORT_LED_R, PIN_LED_R | PIN_LED_G);
    // Blue has its own GPIO port
    gpio_set(PORT_LED_B, PIN_LED_B);
    gpio_mode_setup(PORT_LED_R, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, PIN_LED_R | PIN_LED_G);
    gpio_set_output_options(PORT_LED_R, GPIO_OTYPE_OD, GPIO_OSPEED_2MHZ, PIN_LED_R | PIN_LED_G);
    gpio_mode_setup(PORT_LED_B, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, PIN_LED_B);
    gpio_set_output_options(PORT_LED_B, GPIO_OTYPE_OD, GPIO_OSPEED_2MHZ, PIN_LED_B);

    // 7816 Reset Disable Pin
    // By default this pin is strapped low on the pcb. Thus, if a card reader wants to
    // perform a reset, the STM32 will reset, too. In case you are debugging, you might not
    // want your card to be reset everytime the reader sees a timeout.
    gpio_clear(PORT_ISO7816_RST_DIS, PIN_ISO7816_RST_DIS);
    gpio_mode_setup(PORT_ISO7816_RST_DIS, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, PIN_ISO7816_RST_DIS);
    gpio_set_output_options(PORT_ISO7816_RST_DIS, GPIO_OTYPE_PP, GPIO_OSPEED_2MHZ, PIN_ISO7816_RST_DIS);

    // Clock Source Select Pin CLKSEL
    // When low, the STM32 receives the card reader clock on its HSE pin
    // This means, when selecting HSE as clock source, the controller runs with the wonky reader clock
    // this may be favorable for transmitting the ATR and further communication, but unfavorable for
    // performing measurements. Thus, this signal is high by default.
    gpio_set(PORT_CLKSEL, PIN_CLKSEL);
    gpio_mode_setup(PORT_CLKSEL, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, PIN_CLKSEL);
    gpio_set_output_options(PORT_CLKSEL, GPIO_OTYPE_PP, GPIO_OSPEED_2MHZ, PIN_CLKSEL);

    // Trigger Pin
    gpio_clear(PORT_TRIGGER, PIN_TRIGGER);
    gpio_mode_setup(PORT_TRIGGER, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, PIN_TRIGGER);
    gpio_set_output_options(PORT_TRIGGER, GPIO_OTYPE_PP, GPIO_OSPEED_100MHZ, PIN_TRIGGER);
}

void sys_set_reset_source(uint8_t src)
{
    if (src != SYSTEM_RSTSRC_ISO7816 && src != SYSTEM_RSTSRC_DBG_ONLY)
    {
        // Invalid source has been selected -> exit
        return;
    }

    if (src == SYSTEM_RSTSRC_ISO7816)
        gpio_clear(PORT_ISO7816_RST_DIS, PIN_ISO7816_RST_DIS);
    else
        gpio_set(PORT_ISO7816_RST_DIS, PIN_ISO7816_RST_DIS);

    return;
}

void sys_rcc_init()
{
    // Some general settings for the clock configuration

    // Also the card will never have clock speeds > 8 MHz, so keep the
    // flash wait states at zero
    flash_set_ws(FLASH_ACR_LATENCY_0WS);

    // At this time we are running from the HSI, so 8 MHz
    rcc_ahb_frequency = 8000000;
    rcc_apb1_frequency = 8000000;
    rcc_apb2_frequency = 8000000;
}

// Set the desired clock source for the system.
// Changing the system clock requires adjusting divider
// settings throughout the system for peripherals like USART
void sys_set_clksource(uint8_t src)
{
    if (src != SYSTEM_CLKSOURCE_CARD_TERMINAL && src != SYSTEM_CLKSOURCE_EXT_8MHZ)
    {
        // Invalid source has been selected -> exit
        return;
    }

    // As both clock options are being received through the HSE pin,
    // hop on the internal oscillator for the time between changing
    rcc_osc_on(RCC_HSI);
    rcc_wait_for_osc_ready(RCC_HSI);
    rcc_set_sysclk_source(RCC_HSI);

    rcc_osc_off(RCC_HSE);
    // Bypass the oscillator -> we are supplied by a stable clock
    RCC_CR |= RCC_CR_HSEBYP;

    // The desired clock source is the card terminal
    if (src == SYSTEM_CLKSOURCE_CARD_TERMINAL)
    {
        // Set CLKSEL pin low to disable the pcb oscillator
        // and pass through the card terminal clock
        gpio_clear(PORT_CLKSEL, PIN_CLKSEL);
    }
    else
    {
        gpio_set(PORT_CLKSEL, PIN_CLKSEL);
    }

    // Re-enable the HSE
    rcc_osc_on(RCC_HSE);
    rcc_wait_for_osc_ready(RCC_HSE);
    rcc_set_sysclk_source(RCC_HSE);

    // Turn off the HSI
    rcc_osc_off(RCC_HSI);

    return;
}

void sys_usart_init()
{
    // Enable the USART1 peripheral clock
    rcc_periph_clock_enable(RCC_USART1);

    // Configure GPIOs for USART1 TX
    gpio_mode_setup(PORT_USART1_TX, GPIO_MODE_AF, GPIO_PUPD_NONE, PIN_USART1_TX);
    gpio_set_output_options(PORT_USART1_TX, GPIO_OTYPE_PP, GPIO_OSPEED_2MHZ, PIN_USART1_TX);
    gpio_set_af(PORT_USART1_TX, GPIO_AF1, PIN_USART1_TX);

    // Configure USART1 baudrate
    // F = 372 , D = 1
    // Baudrate = 4750000 / (372 * 1) = 12768.817
    usart_set_baudrate(USART1, (4750000 / (372 * 1)));

    // USART1_GTPR = 16 >> 1; // Prescaler

    // Set the guard time to 2 etu
    USART1_GTPR = 2 << 8;

    // Configure USART1 Smartcard mode
    USART1_CR3 |= USART_CR3_SCEN; // Enable Smartcard mode
    // USART1_CR2 |= USART_CR2_CLKEN;  // Enable the clock output
    // USART1_CR2 &= ~USART_CR2_LINEN; // Disable LIN mode
    USART1_CR2 |= USART_CR2_STOPBITS_1_5 | USART_CR2_CLKEN;
    USART1_CR1 |= USART_CR1_M |   // Enable 9-bit data mode (8-data bits + parity)
                  USART_CR1_PCE | // Enable parity control
                  USART_CR1_TE |  // Enable transmitter
                                  //   USART_CR1_RE |    // Enable receiver
                                  //   USART_CR1_RXNEIE | // Enable RXNE interrupt
                  USART_CR1_UE;   // Enable USART

    // Clear the Transmission Complete flag
    USART1_ICR |= USART_ICR_TCCF;

    // Enable Transmission Complete interrupt
    USART1_CR1 |= USART_CR1_TCIE; //|  // Enable Transmission Complete interrupt
                                  //   USART_CR1_RXNEIE; // Enable Receive Not Empty interrupt

    return;
}

void sys_usart_set_mode_transmit(void)
{

    USART1_CR1 |= USART_CR1_TE;  // Enable transmitter
    USART1_CR1 &= ~USART_CR1_RE; // Disable receiver
}

void sys_usart_set_mode_receive(void)
{

    USART1_CR1 |= USART_CR1_RE; // Enable receiver
                                //   USART_CR1_RXNEIE; // Enable RXNE interrupt

    USART1_CR1 &= ~USART_CR1_TE; // Disable transmitter
}

void sys_usart_send_byte(uint8_t data)
{

    // Send the data
    USART1_TDR = data;
    delay_cyc(372 / 4);
}

void sys_usart_send_bytes(uint8_t *data, size_t len)
{
    sys_usart_set_mode_transmit();

    for (size_t i = 0; i < len; i++)
    {
        // Wait until the transmit buffer is empty
        while (!(USART1_ISR & USART_ISR_TXE))
            ;

        // Send the data
        sys_usart_send_byte(data[i]);
    }

    // Wait for the last byte to complete transmission
    while (!(USART1_ISR & USART_ISR_TC))
        ;

    // Clear the TC flag
    USART1_ICR |= USART_ICR_TCCF;
}

void sys_usart_send_atr(void)
{
    // ATR Sequence (Answer-to-Reset)
    static const uint8_t atr[] = {0x3B, 0x90, 0x11, 0x00}; // ATR bytes as per Python script
    // Send the ATR
    sys_usart_send_bytes(atr, SIZE(atr));
}

// Receive a single byte and return it

uint8_t sys_usart_receive_byte(void)
{
    sys_usart_set_mode_receive();

    // Wait until the receive buffer is full
    while (!(USART1_ISR & USART_ISR_RXNE))
        ;

    // Read the data
    return (uint8_t)USART1_RDR;
}

void delay_cyc(uint32_t cycles)
{
    // The loop translates to roughly two cycles,
    // so just div cycles by two and we good
    cycles = cycles >> 1;
    while (cycles > 0)
    {
        cycles--;
        __asm__("nop");
    }
}

void protocol_challenge_response(void)
{

    // fill the auth_call with random values
    uint8_t auth_chall[16];

    protocol_get_auth_chall(auth_chall);

    uint8_t *auth_resp = auth_chall;

    // AES start

    // AES_ECB_decrypt(const struct AES_ctx* ctx, uint8_t* buf);

    // AES end
    delay_cyc(372 * 10);
    uint8_t resp[] = {0x61, 0x10};
    sys_usart_send_bytes(resp, SIZE(resp));

    protocol_send_auth_resp(auth_resp);
}

void protocol_get_auth_chall(uint8_t *auth_chall)
{

    const uint8_t expected_req[] = {0x88, 0x10, 0x00, 0x00, 0x10};

    protocol_receive_expected_data(expected_req, SIZE(expected_req));

    // Send ACK by the size of the message
    uint8_t ack[] = {0x10};
    sys_usart_send_bytes(ack, SIZE(ack));

    for (int i = 0; i < 16; i++)
    {
        auth_chall[i] = sys_usart_receive_byte();
    }
}

void protocol_send_auth_resp(uint8_t *auth_resp)
{
    uint8_t expected_req[] = {0x88, 0xC0, 0x00, 0x00, 0x10};

    protocol_receive_expected_data(expected_req, SIZE(expected_req));

    // Send ACK => 0xC0
    uint8_t ack[] = {0xC0};
    sys_usart_send_bytes(ack, SIZE(ack));

    sys_usart_send_bytes(auth_resp, 16);

    const uint8_t resp[] = {0x90, 0x00};
    sys_usart_send_bytes((uint8_t *)resp, SIZE(resp));
}

void protocol_receive_expected_data(const uint8_t *data, const uint8_t len)
{

    for (int i = 0; i < len; i++)
    {
        uint8_t byte_expected = data[i];
        uint8_t byte_received = sys_usart_receive_byte();

        if (byte_expected != byte_received)
        {
            gpio_toggle(PORT_LED_R, PIN_LED_R);
            delay_cyc(500000000);
            gpio_toggle(PORT_LED_R, PIN_LED_R);
            delay_cyc(500000000);
        }
    }
}

void assert(bool cond, const char *error_string)
{

    if (!cond)
    {
    }
}